# ìŠ¤í„°ë”” ì½”ì¹˜ ê¸°ìˆ  ì•„í‚¤í…ì²˜ ë¡œë“œë§µ

## ğŸ—ï¸ í˜„ì¬ ì•„í‚¤í…ì²˜ (AS-IS)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Next.js Frontend              â”‚
â”‚   (React 19 + TypeScript)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Next.js API Routes              â”‚
â”‚   (Server-Side Logic)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Prisma ORM                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      SQLite Database                â”‚
â”‚   (prisma/dev.db)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### í˜„ì¬ ì œì•½ì‚¬í•­
- **ë‹¨ì¼ ë°ì´í„°ë² ì´ìŠ¤**: ë™ì‹œ ì ‘ì† ì œí•œ, í™•ì¥ì„± ë¶€ì¡±
- **íŒŒì¼ ê¸°ë°˜ DB**: ë°±ì—…/ë³µêµ¬ ì–´ë ¤ì›€, í´ë¼ìš°ë“œ í˜¸ìŠ¤íŒ… ë¶€ì í•©
- **ì„¸ì…˜ ê´€ë¦¬**: ì„œë²„ ë©”ëª¨ë¦¬ ì˜ì¡´
- **íŒŒì¼ ì €ì¥**: ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ
- **ìºì‹±**: ì—†ìŒ
- **ë¶€í•˜ ë¶„ì‚°**: ë¶ˆê°€ëŠ¥

---

## ğŸ¯ ëª©í‘œ ì•„í‚¤í…ì²˜ (TO-BE) - Phase 3 ì™„ë£Œ ì‹œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            CDN (Vercel Edge Network)                â”‚
â”‚        Static Assets, Edge Functions                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Next.js Frontend (SSR/SSG)                â”‚
â”‚   React 19, TypeScript, Zustand, React Query        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            API Gateway / Load Balancer              â”‚
â”‚          (Vercel Serverless Functions)              â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚              â”‚              â”‚
      â”‚              â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Core     â”‚ â”‚  Payment   â”‚ â”‚   Notification       â”‚
â”‚  Service   â”‚ â”‚  Service   â”‚ â”‚   Service            â”‚
â”‚ (Next.js)  â”‚ â”‚  (Stripe)  â”‚ â”‚ (Firebase/SendGrid)  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”œâ”€â”¤   Redis Cache (Upstash)       â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â””â”€â”¤  PostgreSQL (Primary + Replica)â”‚
        â”‚     (Supabase / Neon)          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   S3-compatible Storage        â”‚
        â”‚  (Cloudflare R2 / AWS S3)      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Phase 1: ì¦‰ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ (Week 1-4)

### 1.1 Database Migration: SQLite â†’ PostgreSQL

#### ì„ íƒì§€ ë¹„êµ

| ì˜µì…˜ | ì¥ì  | ë‹¨ì  | ê°€ê²© |
|------|------|------|------|
| **Supabase** | ë¬´ë£Œ ì‹œì‘, Realtime ì§€ì›, Auth ë‚´ì¥ | í•œêµ­ ë¦¬ì „ ì—†ìŒ | $0-$25/ì›” |
| **Neon** | Serverless, ë¹ ë¥¸ í™•ì¥, í•©ë¦¬ì  ê°€ê²© | í•œêµ­ ë¦¬ì „ ì—†ìŒ | $0-$19/ì›” |
| **AWS RDS** | ì™„ì „í•œ ì œì–´, í•œêµ­ ë¦¬ì „ | ê´€ë¦¬ ë¶€ë‹´, ë¹„ìŒˆ | ~$50/ì›” |
| **Railway** | ê°„ë‹¨í•œ ì„¤ì •, ì¢‹ì€ DX | í•œêµ­ ë¦¬ì „ ì—†ìŒ | $5-$20/ì›” |

#### ì¶”ì²œ: **Neon** (Phase 1-2) â†’ **AWS RDS** (Phase 3+)

**Phase 1-2ì— Neonì„ ì„ íƒí•œ ì´ìœ :**
- Serverless íŠ¹ì„±ìœ¼ë¡œ ì´ˆê¸° íŠ¸ë˜í”½ì— ìµœì 
- ìë™ ìŠ¤ì¼€ì¼ë§
- í•©ë¦¬ì ì¸ ê°€ê²©
- Vercelê³¼ ì›í´ë¦­ í†µí•©

**Phase 3+ AWS RDS ì „í™˜ ì´ìœ :**
- í•œêµ­ ë¦¬ì „ í•„ìš” (ì§€ì—°ì‹œê°„ ìµœì†Œí™”)
- ì™„ì „í•œ ì œì–´ í•„ìš”
- ì—”í„°í”„ë¼ì´ì¦ˆ ê³ ê° ìš”êµ¬ì‚¬í•­

#### Migration ë‹¨ê³„

##### Step 1: Prisma Schema ìˆ˜ì •
```prisma
// prisma/schema.prisma

datasource db {
  provider = "postgresql" // SQLiteì—ì„œ ë³€ê²½
  url      = env("DATABASE_URL")
}

// ê¸°ì¡´ ëª¨ë¸ì€ ëŒ€ë¶€ë¶„ í˜¸í™˜ë¨
// SQLite â†’ PostgreSQL ë³€ê²½ì‚¬í•­:
// - @default(cuid()) â†’ ë™ì¼ ì§€ì›
// - DateTime â†’ TIMESTAMPTZ ìë™ ë§¤í•‘
// - ì¸ë±ìŠ¤ ìµœì í™” í•„ìš”
```

##### Step 2: ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸
```typescript
// scripts/migrate-to-postgresql.ts

import { PrismaClient as SQLiteClient } from '../prisma/generated/sqlite';
import { PrismaClient as PostgresClient } from '@prisma/client';

const sqlite = new SQLiteClient({
  datasources: { db: { url: 'file:./prisma/dev.db' } }
});

const postgres = new PostgresClient({
  datasources: { db: { url: process.env.NEW_DATABASE_URL } }
});

async function migrate() {
  // 1. Academy ë§ˆì´ê·¸ë ˆì´ì…˜
  const academies = await sqlite.academy.findMany();
  await postgres.academy.createMany({ data: academies });

  // 2. User ë§ˆì´ê·¸ë ˆì´ì…˜
  const users = await sqlite.user.findMany();
  await postgres.user.createMany({ data: users });

  // 3. Student, Goal, Grade, Attendance ìˆœì°¨ ë§ˆì´ê·¸ë ˆì´ì…˜
  // ... (ê´€ê³„ ìˆœì„œ ê³ ë ¤)

  console.log('Migration completed!');
}

migrate()
  .catch(console.error)
  .finally(async () => {
    await sqlite.$disconnect();
    await postgres.$disconnect();
  });
```

##### Step 3: ë°ì´í„° ê²€ì¦
```bash
# ë°ì´í„° ì¹´ìš´íŠ¸ ë¹„êµ
sqlite3 prisma/dev.db "SELECT COUNT(*) FROM Academy;"
psql $DATABASE_URL -c "SELECT COUNT(*) FROM \"Academy\";"

# ìƒ˜í”Œ ë°ì´í„° ë¹„êµ
# ê° í…Œì´ë¸”ë³„ ëœë¤ ìƒ˜í”Œ ì¶”ì¶œ ë° ë¹„êµ
```

##### Step 4: ë°°í¬
```bash
# 1. ì‹ ê·œ í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
DATABASE_URL="postgresql://..."

# 2. Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
npx prisma migrate deploy

# 3. ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜
npm run migrate:data

# 4. ê²€ì¦
npm run validate:migration

# 5. ë°°í¬
vercel --prod
```

### 1.2 êµ¬ë… ì‹œìŠ¤í…œ êµ¬í˜„

#### Database Schema ì¶”ê°€

```prisma
// prisma/schema.prisma

model Academy {
  id              String   @id @default(cuid())
  name            String
  address         String?
  phone           String?

  // êµ¬ë… ê´€ë ¨ (ê¸°ì¡´)
  subscriptionPlan String  @default("free")
  subscriptionEnd DateTime?

  // êµ¬ë… ê´€ë ¨ (ì¶”ê°€)
  stripeCustomerId     String?  @unique
  stripeSubscriptionId String?  @unique
  trialEndsAt          DateTime?
  canceledAt           DateTime?

  // í”Œëœ ì œí•œ (ìºì‹±ìš©)
  maxStudents     Int      @default(10)
  maxUsers        Int      @default(2)
  dataRetention   Int      @default(90) // ì¼ ë‹¨ìœ„

  users           User[]
  students        Student[]
  subscriptionHistory SubscriptionHistory[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model SubscriptionHistory {
  id          String   @id @default(cuid())
  academyId   String
  academy     Academy  @relation(fields: [academyId], references: [id])

  plan        String
  status      SubscriptionStatus
  startDate   DateTime
  endDate     DateTime?

  amount      Float
  currency    String   @default("KRW")

  stripeInvoiceId      String?
  stripePaymentIntentId String?

  metadata    Json?

  createdAt   DateTime @default(now())
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
  INCOMPLETE
}

model PlanLimit {
  id              String @id @default(cuid())
  plan            String @unique
  maxStudents     Int
  maxUsers        Int
  dataRetention   Int
  features        Json   // { analytics: true, reports: true, api: false }
  priceMonthly    Float
  priceYearly     Float?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
```

#### Stripe Integration

```typescript
// lib/stripe.ts
import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
});

// í”Œëœ ì •ì˜
export const PLANS = {
  free: {
    name: 'Free',
    price: 0,
    stripePriceId: null,
    limits: {
      maxStudents: 10,
      maxUsers: 2,
      dataRetention: 90,
    },
  },
  starter: {
    name: 'Starter',
    price: 49000,
    stripePriceId: process.env.STRIPE_PRICE_STARTER!,
    limits: {
      maxStudents: 30,
      maxUsers: 5,
      dataRetention: 365,
    },
  },
  professional: {
    name: 'Professional',
    price: 99000,
    stripePriceId: process.env.STRIPE_PRICE_PROFESSIONAL!,
    limits: {
      maxStudents: 100,
      maxUsers: -1, // unlimited
      dataRetention: 1095, // 3ë…„
    },
  },
  enterprise: {
    name: 'Enterprise',
    price: 299000,
    stripePriceId: process.env.STRIPE_PRICE_ENTERPRISE!,
    limits: {
      maxStudents: -1,
      maxUsers: -1,
      dataRetention: -1, // unlimited
    },
  },
};
```

#### API Routes

```typescript
// app/api/subscription/create/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { stripe, PLANS } from '@/lib/stripe';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';

export async function POST(req: NextRequest) {
  const session = await getServerSession();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { plan } = await req.json();

  if (!PLANS[plan as keyof typeof PLANS]) {
    return NextResponse.json({ error: 'Invalid plan' }, { status: 400 });
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    include: { academy: true },
  });

  if (!user?.academy) {
    return NextResponse.json({ error: 'Academy not found' }, { status: 404 });
  }

  // Stripe Customer ìƒì„± (ì—†ìœ¼ë©´)
  let stripeCustomerId = user.academy.stripeCustomerId;

  if (!stripeCustomerId) {
    const customer = await stripe.customers.create({
      email: user.email,
      metadata: {
        academyId: user.academy.id,
        academyName: user.academy.name,
      },
    });

    stripeCustomerId = customer.id;

    await prisma.academy.update({
      where: { id: user.academy.id },
      data: { stripeCustomerId },
    });
  }

  // Checkout Session ìƒì„±
  const checkoutSession = await stripe.checkout.sessions.create({
    customer: stripeCustomerId,
    mode: 'subscription',
    payment_method_types: ['card'],
    line_items: [
      {
        price: PLANS[plan as keyof typeof PLANS].stripePriceId,
        quantity: 1,
      },
    ],
    success_url: `${process.env.NEXT_PUBLIC_URL}/dashboard?subscription=success`,
    cancel_url: `${process.env.NEXT_PUBLIC_URL}/pricing?subscription=canceled`,
    metadata: {
      academyId: user.academy.id,
      plan,
    },
  });

  return NextResponse.json({ url: checkoutSession.url });
}
```

#### Webhook Handler

```typescript
// app/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { stripe } from '@/lib/stripe';
import { prisma } from '@/lib/prisma';
import Stripe from 'stripe';

export async function POST(req: NextRequest) {
  const body = await req.text();
  const sig = req.headers.get('stripe-signature')!;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err: any) {
    return NextResponse.json(
      { error: `Webhook Error: ${err.message}` },
      { status: 400 }
    );
  }

  // ì´ë²¤íŠ¸ ì²˜ë¦¬
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
      break;

    case 'customer.subscription.updated':
      await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
      break;

    case 'customer.subscription.deleted':
      await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
      break;

    case 'invoice.payment_failed':
      await handlePaymentFailed(event.data.object as Stripe.Invoice);
      break;
  }

  return NextResponse.json({ received: true });
}

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const academyId = session.metadata?.academyId;
  const plan = session.metadata?.plan;

  if (!academyId || !plan) return;

  const subscription = await stripe.subscriptions.retrieve(
    session.subscription as string
  );

  await prisma.academy.update({
    where: { id: academyId },
    data: {
      subscriptionPlan: plan,
      stripeSubscriptionId: subscription.id,
      subscriptionEnd: new Date(subscription.current_period_end * 1000),
      maxStudents: PLANS[plan as keyof typeof PLANS].limits.maxStudents,
      maxUsers: PLANS[plan as keyof typeof PLANS].limits.maxUsers,
      dataRetention: PLANS[plan as keyof typeof PLANS].limits.dataRetention,
    },
  });

  // êµ¬ë… íˆìŠ¤í† ë¦¬ ê¸°ë¡
  await prisma.subscriptionHistory.create({
    data: {
      academyId,
      plan,
      status: 'ACTIVE',
      startDate: new Date(subscription.current_period_start * 1000),
      endDate: new Date(subscription.current_period_end * 1000),
      amount: (subscription.items.data[0].price.unit_amount || 0) / 100,
      currency: 'KRW',
      stripeInvoiceId: subscription.latest_invoice as string,
    },
  });
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  // êµ¬ë… ì—…ë°ì´íŠ¸ ì²˜ë¦¬ (í”Œëœ ë³€ê²½, ê°±ì‹  ë“±)
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  // êµ¬ë… ì·¨ì†Œ ì²˜ë¦¬
}

async function handlePaymentFailed(invoice: Stripe.Invoice) {
  // ê²°ì œ ì‹¤íŒ¨ ì²˜ë¦¬ (ì´ë©”ì¼ ì•Œë¦¼ ë“±)
}
```

### 1.3 Middleware: êµ¬ë… ê²€ì¦

```typescript
// middleware/subscription.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';

export async function requireActiveSubscription(req: NextRequest) {
  const session = await getServerSession();

  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    include: { academy: true },
  });

  if (!user?.academy) {
    return NextResponse.json({ error: 'Academy not found' }, { status: 404 });
  }

  const { academy } = user;

  // ë¬´ë£Œ í”Œëœì€ í•­ìƒ í—ˆìš©
  if (academy.subscriptionPlan === 'free') {
    return { academy, limits: PLANS.free.limits };
  }

  // êµ¬ë… ë§Œë£Œ í™•ì¸
  if (!academy.subscriptionEnd || academy.subscriptionEnd < new Date()) {
    return NextResponse.json(
      { error: 'êµ¬ë…ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. êµ¬ë…ì„ ê°±ì‹ í•´ì£¼ì„¸ìš”.' },
      { status: 402 } // Payment Required
    );
  }

  // ì·¨ì†Œëœ êµ¬ë… í™•ì¸
  if (academy.canceledAt && academy.canceledAt < new Date()) {
    return NextResponse.json(
      { error: 'êµ¬ë…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' },
      { status: 402 }
    );
  }

  return {
    academy,
    limits: PLANS[academy.subscriptionPlan as keyof typeof PLANS].limits,
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
export async function checkStudentLimit(academyId: string) {
  const academy = await prisma.academy.findUnique({
    where: { id: academyId },
    include: { _count: { select: { students: true } } },
  });

  if (!academy) throw new Error('Academy not found');

  const currentStudents = academy._count.students;
  const maxStudents = academy.maxStudents;

  if (maxStudents !== -1 && currentStudents >= maxStudents) {
    throw new Error(
      `í˜„ì¬ í”Œëœì˜ í•™ìƒ ìˆ˜ í•œë„(${maxStudents}ëª…)ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ` +
      `í”Œëœì„ ì—…ê·¸ë ˆì´ë“œí•´ì£¼ì„¸ìš”.`
    );
  }

  return true;
}
```

---

## ğŸ“ Phase 2: í™•ì¥ì„± ë° ì„±ëŠ¥ (Week 5-12)

### 2.1 Caching Layer: Redis (Upstash)

#### ì„ íƒ ì´ìœ 
- Serverless-friendly (Vercel í™˜ê²½ì— ìµœì )
- ë¬´ë£Œ ì‹œì‘ ê°€ëŠ¥
- ì§€ì—°ì‹œê°„ ìµœì†Œí™” (ê¸€ë¡œë²Œ ì—£ì§€ ë¡œì¼€ì´ì…˜)

#### êµ¬í˜„

```typescript
// lib/redis.ts
import { Redis } from '@upstash/redis';

export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// ìºì‹± í—¬í¼
export async function cached<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 300 // 5ë¶„
): Promise<T> {
  // ìºì‹œ í™•ì¸
  const cached = await redis.get<T>(key);
  if (cached) return cached;

  // ìºì‹œ ë¯¸ìŠ¤: ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const data = await fetcher();

  // ìºì‹œ ì €ì¥
  await redis.setex(key, ttl, JSON.stringify(data));

  return data;
}

// ìºì‹œ ë¬´íš¨í™”
export async function invalidateCache(pattern: string) {
  const keys = await redis.keys(pattern);
  if (keys.length > 0) {
    await redis.del(...keys);
  }
}
```

#### ì‚¬ìš© ì˜ˆì‹œ

```typescript
// app/api/students/[id]/route.ts
import { cached, invalidateCache } from '@/lib/redis';

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const student = await cached(
    `student:${params.id}`,
    async () => {
      return await prisma.student.findUnique({
        where: { id: params.id },
        include: { goals: true, grades: true, attendances: true },
      });
    },
    600 // 10ë¶„ ìºì‹œ
  );

  return NextResponse.json(student);
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  const data = await req.json();

  const student = await prisma.student.update({
    where: { id: params.id },
    data,
  });

  // ìºì‹œ ë¬´íš¨í™”
  await invalidateCache(`student:${params.id}`);
  await invalidateCache(`academy:${student.academyId}:students`);

  return NextResponse.json(student);
}
```

### 2.2 File Storage: Cloudflare R2

#### ì„ íƒ ì´ìœ 
- S3 í˜¸í™˜ API
- ë¬´ë£Œ egress (ë¹„ìš© ì ˆê°)
- Cloudflare CDN í†µí•©

#### ì„¤ì •

```typescript
// lib/storage.ts
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const s3 = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

export async function uploadFile(
  file: File,
  key: string
): Promise<string> {
  const buffer = Buffer.from(await file.arrayBuffer());

  await s3.send(
    new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      Body: buffer,
      ContentType: file.type,
    })
  );

  return `${process.env.R2_PUBLIC_URL}/${key}`;
}

export async function getSignedDownloadUrl(
  key: string,
  expiresIn: number = 3600
): Promise<string> {
  const command = new GetObjectCommand({
    Bucket: process.env.R2_BUCKET_NAME!,
    Key: key,
  });

  return await getSignedUrl(s3, command, { expiresIn });
}
```

---

## ğŸ“ Phase 3: ì—”í„°í”„ë¼ì´ì¦ˆ ì¤€ë¹„ (Month 5-8)

### 3.1 Multi-Region Database

```
Primary (Seoul): ì“°ê¸° + ì½ê¸°
Replica (Tokyo): ì½ê¸° ì „ìš©
Replica (Singapore): ì½ê¸° ì „ìš©

- ì§€ì—­ë³„ ì½ê¸° ì„±ëŠ¥ ìµœì í™”
- ì¬í•´ ë³µêµ¬ (Disaster Recovery)
- ê³ ê°€ìš©ì„± (High Availability)
```

### 3.2 Observability Stack

```yaml
Logging:
  - Vercel Logs (ê¸°ë³¸)
  - Datadog / New Relic (ê³ ê¸‰)

Monitoring:
  - Sentry (ì—ëŸ¬ ì¶”ì )
  - Vercel Analytics (ì„±ëŠ¥)
  - Uptime Robot (ê°€ë™ ì‹œê°„)

APM:
  - New Relic (Phase 3+)
  - Request tracing
  - Database query ë¶„ì„
```

---

## ğŸš€ ë°°í¬ ì „ëµ

### CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml

name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run lint
      - run: npm run test
      - run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID}}
          vercel-project-id: ${{ secrets.PROJECT_ID}}
          vercel-args: '--prod'
```

---

**ë‹¤ìŒ ë¬¸ì„œ**: [êµ¬í˜„ ìš°ì„ ìˆœìœ„ ë° ì¼ì •](./IMPLEMENTATION_PRIORITY.md)
